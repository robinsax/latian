<!DOCTYPE html>
<html>
    <head>
        <title>latian</title>

        <style>
            * {
                color: rgb(221, 221, 221);
                font-size: 16px;
                font-family: Arial, Helvetica, sans-serif;
                box-sizing: border-box;
            }

            body {
                text-align: center;
                background-color: rgb(30, 30, 30)
            }

            body.connection-error {
                background-color: rgb(142, 36, 36);
            }

            button,
            input {
                border: 1px solid rgb(221, 221, 221);
                border-radius: 4px;
                outline: none;
                padding: 8px;
                background-color: rgb(30, 30, 30);
                margin-right: 8px;
                margin-bottom: 8px;
                cursor: pointer;
            }

            button:hover,
            input:hover {
                background-color: rgb(11, 11, 11);
            }
            
            .output {
                display: inline-block;
                width: 500px;
                text-align: left;
                margin-top: calc(50vh - 250px);
                padding-bottom: 64px;
            }

            .error-message {
                text-align: center;
            }

            .log {
                position: absolute;
                display: inline-block;
                text-align: left;
                width: 350px;
                top: calc(50vh - 250px);
                left: calc(50% + 250px);
                padding-left: 16px;
            }

            .log * {
                font-size: 14px;
            }

            .log .width-a {
                width: 40px;
            }

            .log .width-b {
                width: 120px;
            }

            .input.invalid input {
                background-color: rgb(142, 36, 36);
            }

            .input-label {
                color: rgb(121, 121, 121);
                margin-bottom: 8px;
                margin-top: 16px;
            }
    
            .input-field {
                margin: 0px;
                width: 100%;
            }

            input.input-field {
                width: 60%;
            }

            .signal-only {
                text-align: center;
                margin-top: 32px;
            }

            .signal-only button {
                width: 100%;
                margin: 0px;
            }

            .message {
                margin-bottom: 8px;
            }

            .width-a {
                display: inline-block;
                vertical-align: top;
                width: 60px;
            }

            .width-b {
                display: inline-block;
                vertical-align: top;
                width: 100px;
            }

            .secondary {
                color: rgb(121, 121, 121);
            }

            .timer {
                display: block;
                font-size: 130px;
                text-align: center;
            }
        </style>
    </head>
    <body>
        <div id="root"></div>

        <script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.min.js"></script>
        <script id="module-sys-dummy">
            window.require = () => preact;
            window.exports = window.preactHooks = {};
        </script>
        <script src="https://cdn.jsdelivr.net/npm/preact@10.11.2/hooks/dist/hooks.js"></script>
        <script>{
            const { Fragment, render, h } = preact;
            const { useState, useMemo, useEffect, useRef } = preactHooks;

            const PORT = '$PORT';

            const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));

            const formatDuration = seconds => {
                const negative = seconds < 0;
                if (negative) seconds *= -1;

                let format = (seconds % 60) + 's';
                if (seconds > 60) {
                    format = Math.floor(seconds / 60) + 'm' + format;
                }
                if (negative) {
                    format = '-' + format;
                }

                return format;
            };

            const handleOutput = (currentOutputs, newOutput) => {
                const lastK = currentOutputs.length - 1;

                switch (newOutput.type) {
                    case 'input_invalid':
                        return [
                            ...currentOutputs.slice(0, lastK),
                            { 
                                ...currentOutputs[lastK],
                                data: {
                                    ...currentOutputs[lastK].data,
                                    invalid: true
                                }
                            }
                        ];
                    case 'input_ok':
                        return [
                            ...currentOutputs.slice(0, lastK)
                        ];
                    case 'unwrite_timer':
                        return currentOutputs.filter(check => (
                            check.type != 'timer'
                        ));
                    case 'unwrite_messages':
                        let removed = 0;
                        return currentOutputs.reverse().filter(check => {
                            if (removed >= check.data) return true;
                            if (!['message', 'event'].includes(check.type)) return true;

                            removed++;
                            return false;
                        });
                    default:
                        return [...currentOutputs, newOutput]
                }
            };

            const components = {
                message: ({ data: message }) => (
                    h('div', { class: 'message' }, message)
                ),
                input: ({
                    data: { options, signal_only, message, invalid },
                    sendInput
                }) => (
                    h('div', {
                        class: [
                            'input',
                            invalid && 'invalid',
                            signal_only && 'signal-only'
                        ].filter(check => check).join(' ')
                    }, [
                        h('div', { class: 'input-label' }, message),
                        signal_only ?
                            h('button', {
                                class: 'input-field',
                                onClick: () => sendInput('signal')
                            }, (
                                '✔️'
                            ))
                        : options ?
                            h('div', {
                                class: 'options input-field'
                            }, (
                                options.map(option => (
                                    h('button', {
                                        key: option,
                                        onClick: () => sendInput(option)
                                    }, (
                                        option
                                    ))
                                ))
                            ))
                        :
                            h('input', {
                                class: 'input-field',
                                ref: el => el && el.focus(),
                                onKeyUp: event => {
                                    if (event.which != 13) return;
                                    
                                    sendInput(event.target.value);
                                }
                            })
                    ])
                ),
                timer: ({ data: delay }) => {
                    const [time, setTime] = useState(-delay);

                    useEffect(() => {
                        const start = Date.now() + (delay * 1000);
                        const key = setInterval(() => {
                            const now = Date.now();

                            setTime(Math.floor((now - start) / 1000));
                        }, 100);
                    }, []);

                    return h('dev', { class: 'timer' }, formatDuration(time));
                },
                event: ({ data: { mode, exercise, value, prefix } }) => (
                    h('div', { class: 'message' }, [
                        prefix && h('div', { class: 'secondary width-a' }, prefix),
                        h('div', { class: 'width-b' }, exercise),
                        h('div', { class: 'secondary width-a' }, mode),
                        h('div', { class: 'width-b' }, (
                            mode == 'rep' ?
                                'x' + value
                            :
                                formatDuration(value)
                        ))
                    ])
                ),
                default: ({ type, data }) => (
                    h('div', { class: 'unknown' }, JSON.stringify({ type, data }))
                )
            }

            const Root = () => {
                const [output, setOutput] = useState([]);
                const rawOutput = useRef([]);
                const socket = useRef(null);

                const sendInput = async input => {
                    while (!socket.current) await sleep(0.1);

                    socket.current.send(JSON.stringify({ input }));
                };

                useEffect(async () => {
                    socket.current = new WebSocket('ws://localhost:' + PORT + '/ws');
                    socket.current.addEventListener('message', event => {
                        rawOutput.current = handleOutput(rawOutput.current, JSON.parse(event.data));
                        setOutput(rawOutput.current);
                    });

                    const handleError = () => {
                        document.body.className = 'connection-error';
                        document.body.innerHTML = '<div class="output error-message">error</div>';
                    };
                    socket.current.addEventListener('error', handleError);
                    socket.current.addEventListener('close', handleError);
                }, []);

                return h(Fragment, null, [
                    h('div', { class: 'log' }, (
                        output.map(({ type, data }, k) => (
                            (type == 'event' && data.prefix == '+') &&
                            h(components.event, {
                                key: k, type, data
                            })
                        ))
                    )),
                    h('div', { class: 'output' }, (
                        output.map(({ type, data }, k) => (
                            (type != 'event' || data.prefix != '+') &&
                            h(components[type] || components.default, {
                                key: k, type, data, sendInput
                            })
                        ))
                    ))
                ]);
            };

            render(h(Root), document.querySelector('#root'));
        }</script>
    </body>
</html>
